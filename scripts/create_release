#!/bin/bash

set -ex

MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
WORKSPACE_DIR="$( cd "${MY_DIR}/../.." && pwd )"

RELEASE_DIR="${WORKSPACE_DIR}/${RELEASE_RELATIVE_DIR:-cf-mysql-release}"
OUTPUT_DIR="${WORKSPACE_DIR}/${OUTPUT_DIR:-release-tarball}"
TAG_MATCH=${TAG_MATCH:-}

pushd "${RELEASE_DIR}"

    # If we don't specify the release version manually,
    # Bosh will choose a version number based on what
    # versions are already on the local machine.
    # If the local machine has no existing versions
    # (e.g. the machine is newly created from a Docker image),
    # Bosh will start at Version 0. The problem is that
    # the bosh director we are targeting may already have a
    # Version 0 uploaded, so Bosh will not upload our changes.
    # Manually adding a timestamp to the version number fixes this.
    # We also include the latest OSS release tag in the version for clarity.
    if [ -n "${TAG_MATCH}" ]; then
      GIT_DESCRIBE=$(git describe --long --tags --match ${TAG_MATCH})
    else
      GIT_DESCRIBE=$(git describe --long --tags)
    fi
    GIT_DESCRIBE="${GIT_DESCRIBE#v}" # remove leading 'v'
    MAJOR=$(echo $GIT_DESCRIBE | cut -f1 -d-)
    MINOR=$(echo $GIT_DESCRIBE | cut -f2 -d-)
    SHA=$(echo $GIT_DESCRIBE | cut -f3 -d-)
    VERSION=$MAJOR.$MINOR+$SHA

    CREATE_RELEASE="bosh -n create release --name cf-mysql --version ${VERSION} --with-tarball --force"

    set +e
    CF_MYSQL_OUTPUT=$(${CREATE_RELEASE} 2>&1)
    CF_MYSQL_EXIT_CODE=$?
    set -e

    if [ "${CF_MYSQL_EXIT_CODE}" -ne 0 ]; then
      # retry on blobstore error, else exit

      # turn off trace to avoid printing output twice
      set +x
      if [[ "${CF_MYSQL_OUTPUT}" == *"Blobstore error"* ]]; then
        set -x
        ${CREATE_RELEASE}
        cp dev_releases/cf-mysql/cf-mysql-*.tgz ${OUTPUT_DIR}/
      else
        set -x
        exit ${CF_MYSQL_EXIT_CODE}
      fi
    else
      cp dev_releases/cf-mysql/cf-mysql-*.tgz ${OUTPUT_DIR}/
    fi
popd
