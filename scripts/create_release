#!/bin/bash

set -eux

MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
WORKSPACE_DIR="$( cd "${MY_DIR}/../.." && pwd )"

# Params
: "${RELEASE_NAME:?}"
FINAL=${FINAL:-}
AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}"
AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}"

# Inputs
release_repo="${WORKSPACE_DIR}/release-repo"

# Outputs
release_repo_modified="${WORKSPACE_DIR}/release-repo-modified"
tarball_dir="${WORKSPACE_DIR}/release-tarball"

function write_private_yaml() {
  if [[ -n "${AWS_ACCESS_KEY_ID}" && -n "${AWS_SECRET_ACCESS_KEY}" ]]; then
    pushd "${release_repo}" > /dev/null
      cat <<EOF > config/private.yml
---
blobstore:
  s3:
    access_key_id: ${AWS_ACCESS_KEY_ID}
    secret_access_key: ${AWS_SECRET_ACCESS_KEY}
EOF
    popd > /dev/null
  fi
}

# copy all files, including hidden (e.g. .git/)
shopt -s dotglob

cp -r "${release_repo}"/* "${release_repo_modified}"

pushd "${release_repo_modified}"
    write_private_yaml

    version=$(cat ${WORKSPACE_DIR}/version/version)

    tarball_path="${tarball_dir}/${RELEASE_NAME}-${version}.tgz"

    create_release_command="gobosh -n create-release --name ${RELEASE_NAME} --version ${version} --tarball ${tarball_path} --force"
    if [ -n "${FINAL}" ]; then
      create_release_command="${create_release_command} --final"
    fi

    set +e
    create_release_output=$(${create_release_command} 2>&1)
    create_release_exit_code=$?
    set -e

    if [ "${create_release_exit_code}" -ne 0 ]; then
      # retry on blobstore error, else exit

      # turn off trace to avoid printing output twice
      set +x
      if [[ "${create_release_output}" == *"Blobstore error"* ]]; then
        set -x
        ${create_release_command}
      else
        set -x
        exit "${create_release_exit_code}"
      fi
    fi
popd
