#!/bin/bash

set -eux

MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
WORKSPACE_DIR="$( cd "${MY_DIR}/../.." && pwd )"

# Params
: "${RELEASE_NAME:?}"
FINAL=${FINAL:-}
AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}"
AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}"
BLOBS_BUCKET_NAME="${BLOBS_BUCKET_NAME:-}"

# Inputs
release_repo="${WORKSPACE_DIR}/release-repo"

# Outputs
release_repo_modified="${WORKSPACE_DIR}/release-repo-modified"
tarball_dir="${WORKSPACE_DIR}/release-tarball"

# First argument should be path to file
function write_private_yaml() {
  cat <<EOF > $1
---
blobstore:
  provider: s3
  options:
    bucket_name: ${BLOBS_BUCKET_NAME}
    access_key_id: ${AWS_ACCESS_KEY_ID}
    secret_access_key: ${AWS_SECRET_ACCESS_KEY}
EOF
}

version=$(cat ${WORKSPACE_DIR}/version/version)
tarball_path="${tarball_dir}/${RELEASE_NAME}-${version}.tgz"

create_release_command="bosh -n create-release --name ${RELEASE_NAME} --version ${version} --tarball ${tarball_path} --force"
if [ -n "${FINAL}" ]; then
  create_release_command="${create_release_command} --final"
fi

# copy all files, including hidden (e.g. .git/)
shopt -s dotglob

cp -r "${release_repo}"/* "${release_repo_modified}"

pushd "${release_repo_modified}"
    if [[ -n "${AWS_ACCESS_KEY_ID}" && -n "${AWS_SECRET_ACCESS_KEY}" && -n "${BLOBS_BUCKET_NAME}" ]]; then
      write_private_yaml "${PWD}/config/private.yml"
    fi

    set +e
    create_release_output=$(${create_release_command} 2>&1)
    create_release_exit_code=$?
    set -e

    if [ "${create_release_exit_code}" -ne 0 ]; then
      # retry on blobstore error, else exit

      # turn off trace to avoid printing output twice
      set +x
      if [[ "${create_release_output}" == *"Blobstore error"* ]]; then
        set -x
        ${create_release_command}
      else
        set -x
        exit "${create_release_exit_code}"
      fi
    fi
popd
