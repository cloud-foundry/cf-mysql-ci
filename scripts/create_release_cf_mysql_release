#!/bin/bash

set -ex

MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
WORKSPACE_DIR="$( cd "${MY_DIR}/../.." && pwd )"

RELEASE_DIR="${WORKSPACE_DIR}/${RELEASE_RELATIVE_DIR:?}"

pushd "${RELEASE_DIR}"

    # If we don't specify the release version manually,
    # Bosh will choose a version number based on what
    # versions are already on the local machine.
    # If the local machine has no existing versions
    # (e.g. the machine is newly created from a Docker image),
    # Bosh will start at Version 0. The problem is that
    # the bosh director we are targeting may already have a
    # Version 0 uploaded, so Bosh will not upload our changes.
    # Manually adding a timestamp to the version number fixes this.
    # We also include the latest OSS release tag in the version for clarity.
    LATEST_TAG=$(git describe --tags --abbrev=0)
    LATEST_TAG=${LATEST_TAG#v} # remove leading 'v'
    TIMESTAMP=$(date +%s)
    VERSION="${LATEST_TAG}+dev.${TIMESTAMP}"

    CREATE_RELEASE="bosh -n create release --name cf-mysql --version ${VERSION} --with-tarball --force"

    # TODO: This command is prone to frequent blobstore errors
    # We can remove this once cf-release starts publishing a tarball to S3
    # Story: #96301906
    set +e
    CF_MYSQL_OUTPUT=$(${CREATE_RELEASE} 2>&1)
    CF_MYSQL_EXIT_CODE=$?
    set -e

    if [ "${CF_MYSQL_EXIT_CODE}" -ne 0 ]; then
      # retry on blobstore error, else exit

      # turn off trace to avoid printing output twice
      set +x
      if [[ "${CF_MYSQL_OUTPUT}" == *"Blobstore error"* ]]; then
        set -x
        ${CREATE_RELEASE}
      else
        set -x
        exit ${CF_MYSQL_EXIT_CODE}
      fi
    fi
popd
